<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêõ Bug vs Bunny Chase! üê∞</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Comic Sans MS', cursive, sans-serif;
            color: white;
        }

        #gameContainer {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        #gameCanvas {
            border: 4px solid #fff;
            border-radius: 10px;
            background: #000;
            display: block;
        }

        #hud {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        }

        .hud-item {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            margin: 0 5px;
        }

        #message {
            text-align: center;
            font-size: 28px;
            min-height: 40px;
            margin-top: 15px;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.8);
        }

        #startScreen, #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .screen-title {
            font-size: 48px;
            margin-bottom: 30px;
            text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.9);
        }

        .level-select {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        button {
            padding: 15px 40px;
            font-size: 24px;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border: none;
            border-radius: 50px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6);
        }

        button:active {
            transform: translateY(0);
        }

        .level-btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .hidden {
            display: none !important;
        }

        .stats {
            font-size: 20px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <div class="screen-title">üêõ BUG vs BUNNY üê∞</div>
        <p style="font-size: 20px; max-width: 600px; text-align: center; margin-bottom: 30px;">
            Chase the sneaky bunny and catch it before time runs out!<br>
            Collect carrots ü•ï for bonus points!<br>
            Use arrow keys to move your bug!
        </p>
        <div class="level-select">
            <button class="level-btn" onclick="startGame(1)">üêå LEVEL 1<br>Sleepy Bunny</button>
            <button class="level-btn" onclick="startGame(2)">üèÉ LEVEL 2<br>Speedy Bunny</button>
            <button class="level-btn" onclick="startGame(3)">üß† LEVEL 3<br>Smart Bunny</button>
        </div>
    </div>

    <div id="gameOverScreen" class="hidden">
        <div class="screen-title" id="gameOverTitle"></div>
        <div id="finalStats"></div>
        <button onclick="location.reload()">üîÑ Play Again</button>
    </div>

    <div id="gameContainer" class="hidden">
        <div id="hud">
            <div class="hud-item">‚è±Ô∏è Time: <span id="timer">60</span>s</div>
            <div class="hud-item">ü•ï Score: <span id="score">0</span></div>
            <div class="hud-item">üìä Level: <span id="level">1</span></div>
        </div>
        <canvas id="gameCanvas" width="840" height="930"></canvas>
        <div id="message">Chase that bunny! üèÉ‚Äç‚ôÇÔ∏è</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Classic Pacman maze
        const MAZE = [
            "############################",
            "#          c  c         c  #",
            "# #### ##### ## ##### #### #",
            "# #  # #   # ## #   # #  # #",
            "# #### ##### ## ##### #### #",
            "#  c                    c  #",
            "# #### ##c###### c## #### #",
            "# #### ## ######## ## #### #",
            "#c     ##c   ##   c##     c#",
            "###### ##### ## ##### ######",
            "     # ##### ## #####c#     ",
            "     # ##c        c## #     ",
            "     # ##          ## #     ",
            "###### ##c        c## ######",
            "    c                 c     ",
            "###### ##          ## ######",
            "     # ## c###### c## #     ",
            "     # ##c        c## #     ",
            "     # ## ######## ## #     ",
            "###### ## ######## ## ######",
            "#c       c   ##   c       c#",
            "# #### ##### ## ##### #### #",
            "# #### ##### ## ##### #### #",
            "#c  ##              c##   c#",
            "### ## ## ######## ## ## ###",
            "### ## ##c####### c## ## ###",
            "#c     ##    ##    ##     c#",
            "# ########## ## ########## #",
            "# ##########c##c########## #",
            "#  c                    c  #",
            "############################"
        ];

        const CELL_SIZE = 30;
        const ROWS = MAZE.length;
        const COLS = MAZE[0].length;

        let gameState = {
            bug: { x: 1, y: 1 },
            bunny: { x: 26, y: 29 },
            bunnyHistory: [],
            carrots: [],
            collectedCarrots: new Set(),
            score: 0,
            timeLeft: 60,
            level: 1,
            gameRunning: false,
            bugMoveDelay: 150,
            lastBugMove: 0,
            bunnyMoveDelay: 300,
            lastBunnyMove: 0,
            carrotDropDelay: 1000,
            lastCarrotDrop: 0,
            messages: [
                "üêõ Bug life chose me!",
                "üê∞ Hippity hoppity, you're not catching me!",
                "ü•ï Nom nom nom!",
                "üèÉ Catch me if you can!",
                "üêõ I'm coming for you, cottontail!",
                "üê∞ Nope nope nope!",
                "ü•ï Carrot acquired!",
                "‚ö° Zoom zoom!"
            ]
        };

        const keys = {};

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
                keys[e.key] = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        function isWall(x, y) {
            if (y < 0 || y >= ROWS || x < 0 || x >= COLS) return true;
            const cell = MAZE[y][x];
            return cell === '#' || cell === '-';
        }

        function startGame(level) {
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameContainer').classList.remove('hidden');

            gameState.level = level;
            gameState.timeLeft = 60;
            gameState.score = 0;
            gameState.gameRunning = true;
            gameState.carrots = [];
            gameState.collectedCarrots = new Set();
            gameState.bunnyHistory = [];

            // Reset positions
            gameState.bug = { x: 1, y: 1 };
            gameState.bunny = { x: 26, y: 29 };

            // Adjust difficulty
            switch(level) {
                case 1: // Random movement
                    gameState.bunnyMoveDelay = 400;
                    break;
                case 2: // Faster + basic evasion
                    gameState.bunnyMoveDelay = 250;
                    break;
                case 3: // Smart evasion with pathfinding
                    gameState.bunnyMoveDelay = 200;
                    break;
            }

            document.getElementById('level').textContent = level;
            updateHUD();
            showMessage(gameState.messages[0]);

            startTimer();
            gameLoop();
        }

        function startTimer() {
            const timerInterval = setInterval(() => {
                if (!gameState.gameRunning) {
                    clearInterval(timerInterval);
                    return;
                }

                gameState.timeLeft--;
                updateHUD();

                if (gameState.timeLeft <= 0) {
                    clearInterval(timerInterval);
                    endGame(false);
                }
            }, 1000);
        }

        function updateHUD() {
            document.getElementById('timer').textContent = gameState.timeLeft;
            document.getElementById('score').textContent = gameState.score;
        }

        function showMessage(msg) {
            document.getElementById('message').textContent = msg;
        }

        function moveBug(timestamp) {
            if (timestamp - gameState.lastBugMove < gameState.bugMoveDelay) return;

            const newPos = { ...gameState.bug };
            let moved = false;

            if (keys['ArrowUp']) { newPos.y--; moved = true; }
            else if (keys['ArrowDown']) { newPos.y++; moved = true; }
            else if (keys['ArrowLeft']) { newPos.x--; moved = true; }
            else if (keys['ArrowRight']) { newPos.x++; moved = true; }

            if (!moved) return;

            if (!isWall(newPos.x, newPos.y)) {
                gameState.bug = newPos;
                gameState.lastBugMove = timestamp;

                // Check static carrot in maze
                const mazeCell = MAZE[newPos.y][newPos.x];
                if (mazeCell === 'c') {
                    const key = `${newPos.x},${newPos.y}`;
                    if (!gameState.collectedCarrots.has(key)) {
                        gameState.collectedCarrots.add(key);
                        gameState.score += 10;
                        updateHUD();
                        showMessage(gameState.messages[2]);
                    }
                }

                // Check bunny-dropped carrot collision
                gameState.carrots = gameState.carrots.filter(carrot => {
                    if (carrot.x === newPos.x && carrot.y === newPos.y) {
                        gameState.score += 10;
                        updateHUD();
                        showMessage(gameState.messages[2]);
                        return false;
                    }
                    return true;
                });

                // Check bunny collision
                if (newPos.x === gameState.bunny.x && newPos.y === gameState.bunny.y) {
                    endGame(true);
                }
            }
        }

        function moveBunny(timestamp) {
            if (timestamp - gameState.lastBunnyMove < gameState.bunnyMoveDelay) return;

            gameState.lastBunnyMove = timestamp;

            // Drop carrot at current position
            if (timestamp - gameState.lastCarrotDrop > gameState.carrotDropDelay) {
                gameState.carrots.push({ x: gameState.bunny.x, y: gameState.bunny.y });
                gameState.lastCarrotDrop = timestamp;
            }

            const possibleMoves = [
                { x: gameState.bunny.x, y: gameState.bunny.y - 1 },
                { x: gameState.bunny.x, y: gameState.bunny.y + 1 },
                { x: gameState.bunny.x - 1, y: gameState.bunny.y },
                { x: gameState.bunny.x + 1, y: gameState.bunny.y }
            ].filter(pos => !isWall(pos.x, pos.y));

            if (possibleMoves.length === 0) return;

            // Check distance to bug
            const distanceToBug = Math.abs(gameState.bunny.x - gameState.bug.x) +
                                  Math.abs(gameState.bunny.y - gameState.bug.y);

            // Only avoid recent positions when bug is far (> 8 cells away)
            let movesToConsider = possibleMoves;
            if (distanceToBug > 8) {
                const recentPositions = gameState.bunnyHistory.slice(-10);
                const freshMoves = possibleMoves.filter(move =>
                    !recentPositions.some(pos => pos.x === move.x && pos.y === move.y)
                );
                movesToConsider = freshMoves.length > 0 ? freshMoves : possibleMoves;
            }

            let chosenMove;

            switch(gameState.level) {
                case 1: // Random movement
                    chosenMove = movesToConsider[Math.floor(Math.random() * movesToConsider.length)];
                    break;

                case 2: // Basic evasion - move away from bug
                    chosenMove = movesToConsider.sort((a, b) => {
                        const distA = Math.abs(a.x - gameState.bug.x) + Math.abs(a.y - gameState.bug.y);
                        const distB = Math.abs(b.x - gameState.bug.x) + Math.abs(b.y - gameState.bug.y);
                        return distB - distA; // Prefer farther distance
                    })[0];
                    break;

                case 3: // Smart evasion - BFS pathfinding to maximize distance
                    chosenMove = getBestEvasionMove(movesToConsider);
                    break;
            }

            // Track position history (keep last 12 positions)
            gameState.bunnyHistory.push({ x: gameState.bunny.x, y: gameState.bunny.y });
            if (gameState.bunnyHistory.length > 12) {
                gameState.bunnyHistory.shift();
            }

            gameState.bunny = chosenMove;

            if (Math.random() < 0.2) {
                showMessage(gameState.messages[Math.floor(Math.random() * gameState.messages.length)]);
            }
        }

        function getBestEvasionMove(possibleMoves) {
            // BFS to find move that maximizes path distance from bug
            return possibleMoves.sort((a, b) => {
                const distA = bfsDistance(a, gameState.bug);
                const distB = bfsDistance(b, gameState.bug);
                return distB - distA;
            })[0];
        }

        function bfsDistance(from, to) {
            const queue = [{ ...from, dist: 0 }];
            const visited = new Set([`${from.x},${from.y}`]);

            while (queue.length > 0) {
                const current = queue.shift();

                if (current.x === to.x && current.y === to.y) {
                    return current.dist;
                }

                const neighbors = [
                    { x: current.x, y: current.y - 1 },
                    { x: current.x, y: current.y + 1 },
                    { x: current.x - 1, y: current.y },
                    { x: current.x + 1, y: current.y }
                ];

                for (const neighbor of neighbors) {
                    const key = `${neighbor.x},${neighbor.y}`;
                    if (!isWall(neighbor.x, neighbor.y) && !visited.has(key)) {
                        visited.add(key);
                        queue.push({ ...neighbor, dist: current.dist + 1 });
                    }
                }
            }

            return 999; // Unreachable
        }

        function drawMaze() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const cell = MAZE[y][x];
                    const px = x * CELL_SIZE;
                    const py = y * CELL_SIZE;

                    if (cell === '#' || cell === '-') {
                        ctx.fillStyle = '#0066ff';
                        ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
                        ctx.strokeStyle = '#0044aa';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(px, py, CELL_SIZE, CELL_SIZE);
                    } else if (cell === 'c') {
                        // Draw static carrots
                        const key = `${x},${y}`;
                        if (!gameState.collectedCarrots.has(key)) {
                            ctx.font = '20px Arial';
                            ctx.fillText('ü•ï', px + 5, py + 22);
                        }
                    }
                }
            }
        }

        function drawCarrots() {
            ctx.font = '20px Arial';
            gameState.carrots.forEach(carrot => {
                ctx.fillText('ü•ï', carrot.x * CELL_SIZE + 5, carrot.y * CELL_SIZE + 22);
            });
        }

        function drawEntities() {
            ctx.font = '24px Arial';

            // Draw bug
            ctx.fillText('üêõ', gameState.bug.x * CELL_SIZE + 3, gameState.bug.y * CELL_SIZE + 24);

            // Draw bunny
            ctx.fillText('üê∞', gameState.bunny.x * CELL_SIZE + 3, gameState.bunny.y * CELL_SIZE + 24);
        }

        function render() {
            drawMaze();
            drawCarrots();
            drawEntities();
        }

        function gameLoop(timestamp = 0) {
            if (!gameState.gameRunning) return;

            moveBug(timestamp);
            moveBunny(timestamp);
            render();

            requestAnimationFrame(gameLoop);
        }

        function endGame(won) {
            gameState.gameRunning = false;

            const gameOverScreen = document.getElementById('gameOverScreen');
            const gameOverTitle = document.getElementById('gameOverTitle');
            const finalStats = document.getElementById('finalStats');

            if (won) {
                gameOverTitle.textContent = 'üéâ YOU CAUGHT THE BUNNY! üéâ';
                finalStats.innerHTML = `
                    <div class="stats">ü•ï Final Score: ${gameState.score}</div>
                    <div class="stats">‚è±Ô∏è Time Remaining: ${gameState.timeLeft}s</div>
                    <div class="stats">üìä Level: ${gameState.level}</div>
                    <p style="font-size: 20px; margin-top: 20px;">üê∞ "You got me this time, hooman!"</p>
                `;
            } else {
                gameOverTitle.textContent = '‚è∞ TIME\'S UP! üò¢';
                finalStats.innerHTML = `
                    <div class="stats">ü•ï Final Score: ${gameState.score}</div>
                    <div class="stats">üìä Level: ${gameState.level}</div>
                    <p style="font-size: 20px; margin-top: 20px;">üê∞ "Haha! Better luck next time!"</p>
                `;
            }

            gameOverScreen.classList.remove('hidden');
        }
    </script>
</body>
</html>
